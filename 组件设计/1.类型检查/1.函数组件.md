# 函数组件
## 1.优先使用FunctionComponent类型来声明函数组件
FC是FunctionComponent的简写, 这个类型定义了默认的 props(如 children)以及一些静态属性(如 defaultProps)
```
import React,{FC} from 'react';

//声明Props类型

export interface MyComponentProps{
    className?:string;
    style?:React.CSSProperties;
}

export const MyComponent:FC<MyComponentProps> = props => {
    return <div>hello react</div>;
};
```
直接使用普通函数来进行组件声明

```
export interface MyComponentProps{
    className?:string;
    style?:React.CSSProperties;
    //手动声明children
    children?:React.ReactNode;
}

export function MyComponent(props:MyComponentProps){
    return <div>hello react</div>;
}
```

## 2.不要直接使用export default导出组件
这种方式导出的组件在**React Inspector**查看时会显示为**Unknown**  

```
export default (props:{}) => {
    return <div>hello react</div>;
}
```
如果非得这么做, 请使用命名 function 定义:
```
export default function Foo(props:{}){
    return <div>hello react</div>;
}
```

## 3.默认props声明
```
export interface HelloProps{
    name?:string;//声明为可选属性
}

//利用对象默认属性值语法
export default Hello:FC<HelloProps> = ({name='TJ'}) => <div>Hello {name} </div>;
```

## 4.泛型函数组件
```
import React from 'react';

export interface ListProps<T>{
    visible:boolean;
    list:T[];
    renderItem:(item:T,index:number) => React.ReactNode;
}

export function List<T>(props:ListProps<T>){
    return <div/>
}

//Test
function Test(){
    return (
        <List
         list={[1,2,3]}
         renderItem={i => {
             //自动推断i为number类型
         }}
        />
    )
}
```

## 5.子组件声明
使用Parent.Child形式的 JSX 可以让节点父子关系更加直观, 它类似于一种命名空间的机制, 可以避免命名冲突. 相比ParentChild这种命名方式, Parent.Child更为优雅些.   

```
import React,{PropsWithChildren} from 'react';

export interface LayoutProps {}
export interface LayoutHeaderProps {}
export interface LayoutFooterProps {}

export function Layout(props:PropsWithChildren<LayoutProps>){
    return <div className='layout'>{props.children}</div>;
}

//作为父组件的属性
Layout.Header = (props:PropsWithChildren<LayoutHeaderProps>)=>{
    return <div className="header">{props.children}</div>;
}

Layout.Footer = (props:PropsWithChildren<LayoutFooterProps>) => {
    return <div className="footer">{props.children}</div>;
};

//Test
<Layout>
    <Layout.Header>header</Layout.Header>
    <Layout.Footer>footer</Layout.Footer>
</Layout>
```

## 6.Forwarding Refs
React.forwardRef 在 16.3 新增, 可以用于转发 ref, 适用于 HOC 和函数组件.  

```
//MyModel.tsx

import React,{useState,useImperativeHandle,FC,useRef,useCallback} from 'react';

export interface MyModalProps{
    title?:React.ReactNode;
    onOK?:()=>void;
    onCancel?:()=>void;
}

//暴露的方法, 适用`{ComponentName}Methods`形式命名
export interface MyModalMethods{
    show():void;
}

export const MyModal = React.forwardRef<MyModalMethods,MyModalProps>((props,ref)=>{
    const [visible,setVisibe] = useState();

    //初始化ref暴露的方法
    useImperativeHandle(ref,()=>({
        show:()=>setVisible(true),
    }));

    return <Modal visible={visible}>...</Modal>;
});

//Test.tsx
const Test:FC<{}> = props => {
    //引用
    const modal = useRef<MyModalMethods | null>(null);
    const confirm = useCallback(()=>{
        if(modal.current){
            modal.current.show();
        }
    },[]);

    const handleOK = useCallback(()=>{},[]);

    return (
        <div>
            <button onClick={confirm}>show</button>
            <MyModal ref={modal} onOk={handleOk} />
        </div>
    )
}
```